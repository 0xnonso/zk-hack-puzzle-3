{"noir_version":"0.37.0+5ae0dfc11f4aa9e806cfa533571848c1361a7c7c","hash":12111745706088510286,"abi":{"parameters":[{"name":"identifier","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":128,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"pub_key","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"whitelist","type":{"kind":"array","length":10,"type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},"visibility":"public"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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boFXehsd2eC12EbOA6+WNpS/964Lrzg2lL/3rguv2jWUv3eEGV5Xayh/710XXldrKH/re90Cr6s1lA/fdQdHNnhdraHz7L3rwutqDeXvvevCK18N5e8dYYbXphrK3/tdF16barTrwmtTDeXvfa8Lr001lA/fdQdHNnhtqpHzwGtTDeXvvevCa1MN5e+968JrUw3l7x1hhtemGsrfe9eF16Yayt/7Xhdem2ooH77rDo5s8NpUI+eB16Yayt9714XXphrK33vXpdemGsnfO8JMr001kE+vTTXYdem1qUby977XpdemGsmH77qDI9vetanK3rWpyt61qcretakKvTbVQD69NtVI/t4RZnptqpH8vXddem2qkfy973XptalG8uG77uDItndtqrJ3baqyd22qsndtqkKvTTWSv3eEmV6baiR/73ddem2qwa5Lr001kr/3vS69NtVj+ZVem+rxka3uXZuq7l2bqu5dm6qmrXfdSq9NNZK/dYS50mtTjeRv/a5b6bWpBrsuvTbVSP7W97qVXptqJH/r7gd179pUde/aVHXv2lR179pUlV6baiR/6whzpdemGsnf+12XXptqsOvSa1ON5MN33ZH8re91K7021eDItndtqrp3baq6d22qundtqkqvTTWSv3eEmV6baiQfvuuO5O+969JrU43kb32vW+m1qUbyt+5+UPeuTVX3rk1V965NVfeuTVXptalG8veOMNNrU43k7/2uu7o2lbq9yrdst3qCpWd19aj+N33T47d/r9XloIZ6Fu9c/nYMMy/5Vk+B6Vm8t/gPfy//6Rf+Vs+nN4uaXk6SP71uD/R4ltf58ay3x+bP10j6mB5pr/Pj4v74x+vbT/eY5tvvFr0vRF+F/PCC0H/4509qT/NJ/Wk+aTzLJ/18PadtPml+mk8qT/NJy9N80vo0n7Q9zSd9mjOSPs0ZSZ/mjKRPc0aypzkj2dOckexpzkj2NGekz1cK2+aTPs0ZyZ7mjGRPc0aypzkj2dOckfxpzkj+NGckf5ozkj/NGenzdd22+aRPc0bypzkj+dOckfxpzkj+NGekeJozUjzNGSme5owUT3NG+nwVvm0+6dOckeJpzkjxNGekeJozUjzLGamlZzkjtfQsZ6SWnuWM1NKznJFaqvc+qZcXKsE1P/6kOdIrwRD5LaH5npic0+vnzJJ++NmftTSQFgVpMZAW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","file_map":{"6":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"26":{"source":"pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"34":{"source":"use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE = 16;\n\n// A `u32` integer consists of 4 bytes.\nglobal INT_SIZE = 4;\n\n// Index of the integer in the `INT_BLOCK` where the length is written.\nglobal INT_SIZE_PTR = MSG_SIZE_PTR / INT_SIZE;\n\n// Magic numbers for bit shifting.\n// Works with actual bit shifting as well as the compiler turns them into * and /\n// but circuit execution appears to be 10% faster this way.\nglobal TWO_POW_8 = 256;\nglobal TWO_POW_16 = TWO_POW_8 * 256;\nglobal TWO_POW_24 = TWO_POW_16 * 256;\nglobal TWO_POW_32 = TWO_POW_24 as u64 * 256;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\ntype MSG_BLOCK = INT_BLOCK;\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: INT_BLOCK, _state: STATE) -> STATE {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ];\n    // Pointer into msg_block on a 64 byte scale\n    let mut msg_byte_ptr = 0;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Apply a function on the block item which the pointer indicates.\nfn update_block_item<Env>(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    f: fn[Env](u32) -> u32,\n) -> MSG_BLOCK {\n    let i = msg_byte_ptr / INT_SIZE;\n    msg_block[i] = f(msg_block[i]);\n    msg_block\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::{\n        attach_len_to_msg_block, build_msg_block, byte_into_item, get_item_byte, make_item,\n        set_item_byte_then_zeros, set_item_zeros,\n    };\n    use super::INT_BLOCK;\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n\n    #[test]\n    fn test_get_item_byte() {\n        let fld = make_item(10, 20, 30, 40);\n        assert_eq(fld, 0x0a141e28);\n        assert_eq(get_item_byte(fld, 0), 10);\n        assert_eq(get_item_byte(fld, 4), 10);\n        assert_eq(get_item_byte(fld, 6), 30);\n    }\n\n    #[test]\n    fn test_byte_into_item() {\n        let fld = make_item(0, 20, 0, 0);\n        assert_eq(byte_into_item(20, 1), fld);\n        assert_eq(byte_into_item(20, 5), fld);\n    }\n\n    #[test]\n    fn test_set_item_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 0, 0, 0);\n        assert_eq(set_item_zeros(fld0, 3), fld1);\n        assert_eq(set_item_zeros(fld0, 4), 0);\n        assert_eq(set_item_zeros(0, 4), 0);\n    }\n\n    #[test]\n    fn test_set_item_byte_then_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 50, 0, 0);\n        assert_eq(set_item_byte_then_zeros(fld0, 1, 50), fld1);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_0() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48,\n        ];\n        assert_eq(input.len(), 22);\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 0) };\n        assert_eq(msg_byte_ptr, input.len());\n        assert_eq(msg_block[0], make_item(input[0], input[1], input[2], input[3]));\n        assert_eq(msg_block[1], make_item(input[4], input[5], input[6], input[7]));\n        assert_eq(msg_block[5], make_item(input[20], input[21], 0, 0));\n        assert_eq(msg_block[6], 0);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_1() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        assert_eq(input.len(), 68);\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 64) };\n        assert_eq(msg_byte_ptr, 4);\n        assert_eq(msg_block[0], make_item(input[64], input[65], input[66], input[67]));\n        assert_eq(msg_block[1], 0);\n    }\n\n    #[test]\n    fn test_attach_len_to_msg_block() {\n        let input: INT_BLOCK = [\n            2152555847, 1397309779, 1936618851, 1262052426, 1936876331, 1985297723, 543702374,\n            1919905082, 1131376244, 1701737517, 1417244773, 978151789, 1697470053, 1920166255,\n            1849316213, 1651139939,\n        ];\n        let msg_block = unsafe { attach_len_to_msg_block(input, 1, 448) };\n        assert_eq(msg_block[0], ((1 << 7) as u32) * 256 * 256 * 256);\n        assert_eq(msg_block[1], 0);\n        assert_eq(msg_block[15], 3584);\n    }\n}\n","path":"std/hash/sha256.nr"},"69":{"source":"// THIS FILE CANNOT BE CHANGED\n\nuse noir_string_search::{StringBody, StringBody128, SubString, SubString32};\n\n// alice_pk = [155, 143, 27, 66, 87, 125, 33, 110, 57, 153, 93, 228, 167, 76, 120, 220, 178, 200, 187, 35, 211, 175, 104, 63, 140, 208, 36, 184, 88, 1, 203, 62]\n// alice_pepper = [213, 231, 76, 105, 105, 96, 199, 183, 106, 26, 29, 7, 28, 234, 145, 69, 48, 9, 254, 205, 79, 21, 90, 13, 39, 172, 114, 59, 131, 15, 78, 118]\n\nfn main(identifier: BoundedVec<u8, 128>, pub_key: pub [u8; 32], whitelist: pub [[u8; 32]; 10]) {\n    // let suspect1 = \n    // println(std::hash::sha256_var(suspect1, 65));\n    // the identifier hashes to a digest that is in the public whitelist\n    let digest = std::hash::sha256_var(identifier.storage(), identifier.len() as u64);\n    let mut present = false;\n    for i in 0..whitelist.len() {\n        if whitelist[i] == digest {\n            present = true;\n        }\n    }\n    assert(present);\n\n    // the specified public key is in the identifier\n    let id_haystack: StringBody128 = StringBody::new(identifier.storage(), 128);\n    let pk_needle: SubString32 = SubString::new(pub_key, 32);\n    let (result, _): (bool, u32) = id_haystack.substring_match(pk_needle);\n    assert(result);\n}\n // {9b8f1b42577d216e39995de4a74c78dcb2c8bb23d3af683f8cd024b85801cb3e}_{d5e74c696960c7b76a1a1d071cea91453009fecd4f155a0d27ac723b830f4e76}","path":"/Users/nonso/Documents/0xNonso/puzzle-shadow/src/main.nr"},"70":{"source":"mod utils;\n\npub use utils::{conditional_select, lt_f, DebugRandomEngine};\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"haystack\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\"\n * @details the \"body\" parameter contains some input bytes, zero-padded to the nearest multiple of 31\n *          We pack \"bytes\" into 31-byte \"chunks\", as this is the maximum number of bytes we can fit\n *          into a field element without overflowing.\n *          TODO: once we can derive generics via arithmetic on other generics, we want this \"31\" parameter\n *          to be defined by the backend being used instead of being hardcoded to 31\n *\n * @note We perform this 31-byte packing because it dramatically reduces the number of constraints required for substring matching. See (chicken)\n *\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunks: the number of 31-byte chunks needed to represent MaxPaddedBytes\n **/\npub struct StringBody<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> {\n    pub body: [u8; MaxPaddedBytes],\n    chunks: [Field; PaddedChunks],\n    pub byte_length: u32,\n}\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"needle\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\"\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunksMinusOne: the number of 31-byte chunks needed to represent MaxPaddedBytes minus one!\n *\n * @note PaddedChunksMinusOne is because we are going to do the following:\n *                            1. align the SubString bytes according to the StringBody bytes being matched against\n *                            2. split the aligned bytes into 31-byte chunks. The 1st and last chunks might contain\n *                               fewer than 31 bytes due to the above alignment\n *                            3. validate the aligned-byte-chunks match the StringBody byte chunks\n *       To account for the fact that the 1st and last chunks might have fewer bytes we treat those separately\n *       The param PaddedChunksMinusOne is the number of 31-byte chunks required to represent SubString *EXCLUDING* the initial and final chunks\n */\npub struct SubString<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> {\n    pub body: [u8; MaxPaddedBytes],\n    pub byte_length: u32,\n}\n\npub type StringBody32 = StringBody<62, 2, 32>;\npub type StringBody64 = StringBody<93, 3, 64>;\npub type StringBody128 = StringBody<155, 5, 128>;\npub type StringBody256 = StringBody<279, 9, 256>;\npub type StringBody512 = StringBody<527, 17, 512>;\npub type StringBody1024 = StringBody<1054, 34, 1024>;\npub type StringBody2048 = StringBody<2077, 67, 2048>;\npub type StringBody4096 = StringBody<4123, 133, 4096>;\npub type StringBody8192 = StringBody<8215, 265, 8192>;\npub type StringBody16384 = StringBody<16399, 529, 16384>;\n\npub type SubString32 = SubString<62, 1, 32>;\npub type SubString64 = SubString<93, 2, 64>;\npub type SubString128 = SubString<155, 4, 128>;\npub type SubString256 = SubString<279, 8, 256>;\npub type SubString512 = SubString<527, 16, 512>;\npub type SubString1024 = SubString<1054, 33, 1024>;\n\npub trait SubStringTrait {\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        num_bytes_in_first_chunk: Field,\n        body_chunk_offset: Field,\n        num_full_chunks: Field,\n    );\n\n    fn len(self) -> u32;\n    fn get(self, idx: Field) -> u8;\n    fn get_body(self) -> [u8];\n}\n\n// ######################################################\n// S U B S T R I N G\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    /**\n     * @brief construct a SubString object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    fn new<let InputBytes: u32>(input: [u8; InputBytes], input_length: u32) -> Self {\n        assert(MaxBytes <= MaxPaddedBytes);\n        assert(input_length <= MaxBytes);\n        assert(InputBytes <= MaxBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = input[i];\n        }\n        SubString { body, byte_length: input_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together\n     * @details each SubString can have different MaxBytes sizes, however we need OtherBytes <= MaxBytes\n     *          (use concat_into for cases where this is not the case)\n     **/\n    fn concat<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>,\n    ) -> Self {\n        assert(\n            OtherPaddedBytes <= MaxPaddedBytes,\n            \"SubString::concat. SubString being concatted has larger max length. Try calling concat_into\",\n        );\n        assert(\n            self.byte_length + other.byte_length <= MaxPaddedBytes,\n            \"SubString::concat, concatenated string exceeds MaxPaddedBytes\",\n        );\n        let mut body = self.body;\n        let offset: u32 = self.byte_length;\n        for i in 0..MaxPaddedBytes {\n            if (i + offset < MaxPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together. Return type has OtherPaddedBytes max bytes\n     * @details each SubString can have different MaxBytes sizes, however we need MaxBytes <= OtherBytes\n     *          (use concat for cases where this is not the case)\n     **/\n    fn concat_into<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>,\n    ) -> SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes> {\n        assert(\n            MaxPaddedBytes <= OtherPaddedBytes,\n            \"SubString::concat_into. SubString being concat has larger max length. Try calling concat\",\n        );\n        assert(\n            self.byte_length + other.byte_length <= OtherPaddedBytes,\n            \"SubString::concat_into, concatenated string exceeds MaxPaddedBytes\",\n        );\n        let mut body: [u8; OtherPaddedBytes] = [0; OtherPaddedBytes];\n        for i in 0..MaxBytes {\n            body[i] = self.body[i];\n        }\n\n        let offset: u32 = self.byte_length;\n        for i in 0..OtherPaddedBytes {\n            if (i + offset < OtherPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubStringTrait for SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    fn len(self) -> u32 {\n        self.byte_length\n    }\n    fn get(self, idx: Field) -> u8 {\n        self.body[idx]\n    }\n    fn get_body(self) -> [u8] {\n        let x = self.body.as_slice();\n        x\n    }\n\n    /**\n     * @brief given some `haystack` 31-byte chunks, validate that there exist `num_full_chunks`\n     *        in the SubString, starting at byte position `starting_needle_byte`.\n     *        The selected chunks must be equal to the haystack chunks starting at `starting_haystack_chunk`\n     **/\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        starting_needle_byte: Field,\n        starting_haystack_chunk: Field,\n        num_full_chunks: Field,\n    ) {\n        let mut substring_chunks: [Field; PaddedChunksMinusOne] = [0; PaddedChunksMinusOne];\n        // pack the substring into 31 byte chunks.\n        // This is fairly expensive as we need a ROM table to access the SubString.body\n        // which is 2 gates per byte\n        for i in 0..PaddedChunksMinusOne {\n            let mut slice: Field = 0;\n            for j in 0..31 {\n                slice *= 256;\n                let substring_idx = starting_needle_byte as Field + (i as Field * 31) + j as Field;\n                let mut byte = self.body[substring_idx];\n                slice += byte as Field;\n            }\n            std::as_witness(slice);\n            substring_chunks[i] = slice;\n        }\n        // iterate over the needle chunks and validate they match the haystack chunks\n        for i in 0..PaddedChunksMinusOne {\n            let predicate: Field = lt_f(i as Field, num_full_chunks) as Field;\n            let lhs = substring_chunks[i];\n            let rhs = haystack[predicate as Field * (i as Field + starting_haystack_chunk)];\n            assert(predicate * (lhs - rhs) == 0);\n        }\n    }\n}\n\n// ######################################################\n// S T R I N G   B O D Y\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> StringBody<MaxPaddedBytes, PaddedChunks, MaxBytes> {\n\n    /**\n     * @brief construct a StringBody object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    fn new<let InputBytes: u32>(data: [u8; InputBytes], length: u32) -> Self {\n        assert(length <= MaxBytes);\n        assert(length <= InputBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = data[i];\n        }\n        StringBody { body, chunks: compute_chunks(body), byte_length: length }\n    }\n\n    /**\n     * @brief Validate a substring exists in the StringBody. Returns a success flag and the position within the StringBody that the match was found\n     **/\n    fn substring_match<NeedleSubString>(self, substring: NeedleSubString) -> (bool, u32)\n    where\n        NeedleSubString: SubStringTrait,\n    {\n        // use unconstrained function to determine:\n        // a: is the substring present in the body text\n        // b: the position of the first match in the body text\n        let position: u32 = unsafe {\n            // Safety: The rest of this function checks this.\n            utils::search(\n                self.body,\n                substring.get_body(),\n                self.byte_length,\n                substring.len(),\n            )\n        };\n\n        assert(\n            position + substring.len() <= self.byte_length,\n            \"substring not present in main text (match found if a padding text included. is main text correctly formatted?)\",\n        );\n        let substring_length = substring.len();\n\n        // chunk_index = which 31-byte haystack chunk does the needle begin in?\n        let chunk_index: u32 = position / 31;\n        // chunk_offset = how many haystack bytes are present in the 1st haystack chunk?\n        let chunk_offset: u32 = position % 31;\n        // how many needle bytes are in 1st haystack chunk?\n        let num_bytes_in_first_chunk: u32 = 31 - chunk_offset;\n        let mut starting_needle_byte_index_of_final_chunk: Field = 0;\n        let mut chunk_index_of_final_haystack_chunk_with_matching_needle_bytes: Field = 0;\n        let mut num_full_chunks = 0;\n\n        // is there only one haystack chunk that contains needle bytes?\n        let merge_initial_final_needle_chunks =\n            lt_f(substring_length as Field, num_bytes_in_first_chunk as Field);\n\n        // if the above is false...\n        if (!merge_initial_final_needle_chunks) {\n            // compute how many full 31-byte haystack chunks contain 31 needle bytes\n            num_full_chunks = (substring_length - num_bytes_in_first_chunk) / 31;\n            // for the final haystack chunk that contains needle bytes, where in the needle does this chunk begin?\n            starting_needle_byte_index_of_final_chunk =\n                num_full_chunks as Field * 31 + num_bytes_in_first_chunk as Field;\n            // what is the index of the final haystack chunk that contains needle bytes?\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes =\n                num_full_chunks as Field + chunk_index as Field + 1;\n        } else {\n            starting_needle_byte_index_of_final_chunk = 0;\n            // if the needle bytes does NOT span more than 1 haystack chunk,\n            // the final haystack index will be the same as the initial haystack index\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes = chunk_index as Field;\n        }\n\n        // To minimize the number of comparisons between the haystack bytes and the needle bytes,\n        // we pack both the haystack bytes and needle bytes into 31-byte Field \"chunks\" and compare chunks.\n        // To do this correctly, we need to align the needle chunks with the haystack chunks\n        /*\n            e.g. consider a toy example where we pack 3 bytes into a chunk\n            haystack: [VWXZYABCDEQRSTU]\n            needle: [ABCDE]\n        when constructing needle chunks, we need to align according to where the needle is located in the haystack\n            haystack chunks:   [VWX] [ZYA] [BCD] [EQR] [STU]\n                                      _..   ...   .__\n            processed needle chunks: [ZYA] [BCD] [EQR]\n        a \"_\" symbole means that a chunk byte has been sourced from the haystack bytes,\n            a \".\" symbol means a byte is sourced from the needle bytes\n        Both the initial and final chunks of the processed needle are \"composite\" constructions.\n            If chunk byte index < `position` or is > `position + needle length\", byte is sourced from haystack, otherwise byte is sourced from needle\n        The way we execute this in code is to define an \"initial\" needle chunk and a \"final\" needle chunk.\n            Num needle bytes in initial chunk = position % 31\n            Num needle bytes in final chunk = (needle_length - (position % 31)) % 31\n        If needle_length < 31 then the \"initial\" and \"final\" chunks\n            are actually the *same* chunk and we must perform a merge operation\n            (see later in algo for comments)\n        */\n        // instead of directly reading haystack bytes, we derive the bytes from the haystack chunks.\n        // This way we don't have to instantiate the haystack bytes as a ROM table, which would cost 2 * haystack.length gates\n        let offset_to_first_needle_byte_in_chunk: Field = chunk_offset as Field;\n        let initial_haystack_chunk = self.chunks[chunk_index];\n        let final_haystack_chunk =\n            self.chunks[chunk_index_of_final_haystack_chunk_with_matching_needle_bytes];\n\n        let initial_body_bytes: [u8; 31] = initial_haystack_chunk.to_be_bytes();\n        let final_body_bytes: [u8; 31] = final_haystack_chunk.to_be_bytes();\n\n        // When defining the initial chunk bytes, we can represent as Field elements as we are deriving values from known bytes.\n        // This saves us a few gates\n        let mut initial_chunk: [Field; 31] = [0; 31];\n        let mut final_chunk: [Field; 31] = [0; 31];\n        for i in 0..31 {\n            // if i < offset_to_first_needle_byte_in_chunk, we read from the haystack\n            // otherwise we read from the needle\n            // n.b. this can be done with an if statement, but the following code produces fewer constraints\n            let idx: Field = i as Field;\n            let predicate: Field = lt_f(i as Field, offset_to_first_needle_byte_in_chunk) as Field;\n            let lhs: Field = initial_body_bytes[i] as Field;\n            // if i < offset_to_first_needle_byte_in_chunk then `idx - offset_to_first_needle_byte_in_chunk` is negative\n            // to ensure we access array correctly we need to set the lookup index to 0 if predicate = 0\n            let substring_idx = (1 - predicate) * (idx - offset_to_first_needle_byte_in_chunk);\n            let rhs: Field = substring.get(substring_idx) as Field;\n            let byte: Field = predicate * (lhs - rhs) + rhs;\n            initial_chunk[i] = byte;\n        }\n\n        // If `merge_initial_final_needle_chunks = true`, `final_chunk` will contain the full needle data,\n        // this requires some complex logic to determine where we are sourcing the needle bytes from.\n        // Either they come from the `initial_chunk`, the haystack bytes or the substring bytes.\n        for i in 0..31 {\n            let mut lhs_index: Field =\n                starting_needle_byte_index_of_final_chunk as Field + i as Field;\n            let predicate = lt_f(lhs_index, substring_length as Field);\n\n            /*\n                | merge_initial_final_needle_chunks | predicate | byte_source              |\n                | false                             | false     | body_bytes[i]            |\n                | false                             | true      | substring[lhs_idx]       |\n                | true                              | false     | body_bytes[i]            |\n                | true                              | true      | initial_chunk[lhs_index] |\n            NOTE: if `merge = true` and `predicate = true`, we read from `initial_chunk` to short-circuit some extra logic.\n                      if `initial_chunk` did not exist, then we would need to validate whether `i < offset_to_first_needle_byte_in_chunk`.\n                      if true, the byte source would be body_bytes, otherwise the source would be substring bytes\n            */\n            let byte_from_substring = substring.get(lhs_index) as Field;\n            let byte_from_initial_chunk = initial_chunk[i] as Field;\n            let byte_from_haystack = final_body_bytes[i] as Field;\n\n            // TODO: find out why this cuts 1 gate per iteration\n            std::as_witness(byte_from_initial_chunk);\n\n            let p = predicate as Field;\n            let m = merge_initial_final_needle_chunks as Field;\n            // p * (m * (a - b) + (b - c)) + c\n            let ab = byte_from_initial_chunk - byte_from_substring;\n            std::as_witness(ab);\n            let bc = byte_from_substring - byte_from_haystack;\n            let t0 = m * ab + bc;\n            let destination_byte = p * t0 + byte_from_haystack;\n\n            final_chunk[i] = destination_byte;\n        }\n\n        // TODO: moving this above the previous code block adds 31 gates. find out why? :/\n        let mut initial_needle_chunk: Field = 0;\n        let mut final_needle_chunk: Field = 0;\n\n        // Construct the initial and final needle chunks from the byte arrays we previously built.\n        // Validate they match the initial and final haystack chunks\n        for i in 0..31 {\n            initial_needle_chunk *= 256;\n            initial_needle_chunk += initial_chunk[i];\n            final_needle_chunk *= 256;\n            final_needle_chunk += final_chunk[i];\n        }\n\n        std::as_witness(initial_needle_chunk);\n        std::as_witness(final_needle_chunk);\n\n        initial_needle_chunk = merge_initial_final_needle_chunks as Field\n            * (final_needle_chunk - initial_needle_chunk)\n            + initial_needle_chunk;\n        assert(initial_needle_chunk == initial_haystack_chunk);\n        assert(final_needle_chunk == final_haystack_chunk);\n\n        // Step 3: Construct needle chunks (for all but the 1st and last chunks) and validate they match the haystack chunks.\n        //         This part is much simpler as we know that all bytes in the chunk are sourced from the needle chunk.\n        // NOTE:   If we chose to not pack bytes into 31-byte chunks, the string matching algorithm would be simpler but more expensive.\n        //         Instead of matching chunks with each other, we would match individual byte values.\n        //         i.e. the number of iterations in this loop would be 31x greater\n        //         each loop iteration would also require a predicate, to check whether the byte index was within the needle range or not\n        //         Combined these two operations would add about 10 gates per loop iteration,\n        //         combined with a 31x iteration length would make this algorithm much more costly than the chunked variant\n        let body_chunk_offset: Field = chunk_index as Field + 1;\n        substring.match_chunks(\n            self.chunks,\n            num_bytes_in_first_chunk as Field,\n            body_chunk_offset,\n            num_full_chunks as Field,\n        );\n        (true, position)\n    }\n}\n\n/// Given an input byte array, convert into 31-byte chunks\n///\n/// Cost: ~0.5 gates per byte\nfn compute_chunks<let MaxPaddedBytes: u32, let PaddedChunks: u32>(\n    body: [u8; MaxPaddedBytes],\n) -> [Field; PaddedChunks] {\n    let mut chunks: [Field; PaddedChunks] = [0; PaddedChunks];\n    for i in 0..PaddedChunks {\n        let mut limb: Field = 0;\n        for j in 0..31 {\n            limb *= 256;\n            limb += body[i * 31 + j] as Field;\n        }\n        chunks[i] = limb;\n        std::as_witness(chunks[i]);\n    }\n    chunks\n}\n\n#[test]\nfn test() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_small_needle() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \"olor\".as_bytes();\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString32 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_aligned_on_byte_boundary() {\n    let haystack_text = \"the quick brown fox jumped over the lazy dog\".as_bytes();\n    let needle_text = \" the lazy dog\".as_bytes();\n\n    let mut haystack: StringBody256 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString256 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_haystack_equal_size() {\n    let haystack_text =\n        \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n    let needle_text = \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n\n    let mut haystack: StringBody64 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_concat() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString128 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nfn test_concat_into() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString32 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat_into(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nunconstrained fn test_partial_match() {\n    let mut Engine = DebugRandomEngine { seed: 0 };\n    let mut foo: [u8; 1024] = Engine.get_random_bytes();\n    let mut bar: [u8; 128] = [0; 128];\n    for i in 0..128 {\n        bar[i] = foo[i + 123];\n    }\n    let position = utils::search(foo, bar.as_slice(), 1024, 128);\n\n    assert(position == 123);\n}\n","path":"/Users/nonso/nargo/github.com/noir-lang/noir_string_search.gitv0.3.0/src/lib.nr"},"71":{"source":"pub unconstrained fn search<let N: u32>(\n    haystack: [u8; N],\n    needle: [u8],\n    haystack_length: u32,\n    needle_length: u32,\n) -> u32 {\n    assert(needle_length > 0, \"needle length of size 0 not supported\");\n    assert(haystack_length > 0, \"haystack length of size 0 not supported\");\n    let mut found = false;\n    let mut found_index: u32 = 0;\n    for i in 0..haystack_length - needle_length + 1 {\n        if (found == true) {\n            break;\n        }\n        for j in 0..needle_length {\n            if haystack[i + j] != needle[j] {\n                break;\n            } else if (j == needle_length - 1) {\n                found = true;\n            }\n            if (found == true) {\n                found_index = i;\n                break;\n            }\n        }\n    }\n    assert(found == true, \"utils::search could not find needle in haystack\");\n    found_index\n}\n\nunconstrained fn __conditional_select(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    if (predicate) {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub fn conditional_select<T>(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    // Safety: This is all just a very verbose `if (predicate) { lhs } else { rhs }`\n    // formulated as `rhs + (lhs - rhs) * predicate`\n    unsafe {\n        let result = __conditional_select(lhs, rhs, predicate);\n        let result_f = result as Field;\n        let lhs_f = lhs as Field;\n        let rhs_f = rhs as Field;\n\n        let diff = lhs_f - rhs_f;\n        std::as_witness(diff);\n        assert_eq((predicate as Field) * diff + rhs_f, result_f);\n        result\n    }\n}\n\npub unconstrained fn get_lt_predicate_f(x: Field, y: Field) -> bool {\n    let a = x as u32;\n    let b = y as u32;\n    a < b\n}\n\npub fn lt_f(x: Field, y: Field) -> bool {\n    // Safety: As `x` and `y` are known to be valid `u32`s, this function reimplements the\n    // compiler's internal implementation of `lt`\n    unsafe {\n        let predicate = get_lt_predicate_f(x, y);\n        let delta = y as Field - x as Field;\n        let lt_parameter = 2 * (predicate as Field) * delta - predicate as Field - delta;\n        lt_parameter.assert_max_bit_size::<32>();\n\n        predicate\n    }\n}\n\npub struct DebugRandomEngine {\n    pub seed: Field,\n}\n\nimpl DebugRandomEngine {\n    unconstrained fn get_random_32_bytes(&mut self) -> [u8; 32] {\n        self.seed += 1;\n        let input: [u8; 32] = self.seed.to_be_bytes();\n        let hash: [u8; 32] = dep::std::hash::sha256(input);\n        hash\n    }\n    unconstrained fn get_random_field(&mut self) -> Field {\n        let hash = self.get_random_32_bytes();\n        let mut result: Field = 0;\n        for i in 0..32 {\n            result *= 256;\n            result += hash[i] as Field;\n        }\n        result\n    }\n\n    pub unconstrained fn get_random_bytes<let NBytes: u32>(&mut self) -> [u8; NBytes] {\n        let num_chunks = (NBytes / 32) + ((NBytes % 32) != 0) as u32;\n\n        let mut result: [u8; NBytes] = [0; NBytes];\n        for i in 0..num_chunks - 1 {\n            let bytes = self.get_random_32_bytes();\n            for j in 0..32 {\n                result[i * 32 + j] = bytes[j];\n            }\n        }\n\n        let bytes = self.get_random_32_bytes();\n        for j in 0..(NBytes - (num_chunks - 1) * 32) {\n            result[(num_chunks - 1) * 32 + j] = bytes[j];\n        }\n        result\n    }\n}\n","path":"/Users/nonso/nargo/github.com/noir-lang/noir_string_search.gitv0.3.0/src/utils.nr"}},"names":["main"],"brillig_names":["build_msg_block","attach_len_to_msg_block","search","get_lt_predicate_f","directive_integer_quotient","directive_invert"]}